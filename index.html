<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Lecture 3</title>

		<link rel="shortcut icon" type="image/x-icon" href="uu_logo/UU_logo_color-cropped.ico">

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">
		<link rel="stylesheet" href="reveal.js/dist/theme/black.css">

		<!-- Tabler icons -->
		<link rel="stylesheet" href="tabler-icons/packages/icons-webfont/tabler-icons.min.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="atomic-one-dark.css">

		<!-- Custom css -->
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<img class="logo" src="uu_logo/UU_logo_vit-cropped.svg">
		<div class="reveal">
			<div class="slides">
<!-- BEGIN SLIDES -->
<section data-background-image="images/background.jpg" data-background-opacity="0.4">
	<h1>Lecture 4</h1>
	<p>Nikolaus Huber</p>
</section>

<section data-background-image="images/specification.jpg" data-background-opacity="0.3">
	<h1>Specification</h1>
</section>

<section data-background-color="white">
	<h3>Systems development lifecycle</h3>
	<img class="r-stretch" src="images/v_diagram.svg">
</section>

<section>
	<h3>Outline</h3>
	<ul>
		<li>Informal (system-level) specification</li>
		<li>Requirements engineering</li>
		<li>Formal specification</li>
	</ul>
</section>

<section>
	<h3>Requirements engineering</h3>
	
	<ul>
		<li>Often collected during discussions/negotiations between stakeholders 
		<ul>
			<li>Customer</li>
			<li>System designer</li>
			<li>Software provider</li>
			<li>...</li>
		</ul>
	</ul>

	<div style="margin-top: 1rem" class="citation">
		<div class="cite">It is widely acknowledged amongst researchers and industry practitioners that software projects 
			are critically vulnerable when the requirements- related activities are poorly performed.
		</div>
		<div class="source">
			P. Bourque and R.E. Fairley, SWEBOK Version 3.0, IEEE Computer Society
		</div>
	</div>
</section>

<section>
	<h3>Types of requirements (FURPS+) </h3>

		<div class="half-part">
		<ul>
			<li>Functionality</li>
			<ul>
				<li>Features, capabilities, security</li>
			</ul>
			<li>Usability</li>
			<ul>
				<li>Human-Computer Interaction</li>
				<li>Documentation</li>
			</ul>
			<li>Reliability</li>
			<ul>
				<li>Frequency of failure</li>
				<li>Error recovery</li>
			</ul>
		</ul>
	</div>
	<div class="half-part">
		<ul>
			<li>Performance</li>
			<ul>
				<li>Response time</li>
			</ul>
			<li>Supportability</li>
			<ul>
				<li>Adaptability, Configurability</li>
				<li>Maintenance</li>
			</ul>
			<li>Many others</li>
			<ul>
				<li>Implementation</li>
				<li>User interface</li>
				<li>Licencing</li>
			</ul>
		</ul>
	</div>
</section>

<section>
	<h3>Standards (examples)</h3>
	<ul>
		<li>ISO/IEC/IEEE 12207:2017(E) - International Standard - Systems and software engineering -- Software life cycle processes</li>
		<ul>
			<li>6.4.2: Stakeholder Needs and Requirements Definition process</li>
			<li>6.4.3: System/Software requirements definition process</li>
		</ul>
		<li>ECSS-E-ST-40C - Software (2009)</li>
		<ul>
			<li>4.2.4: Software requirements and architecture engineering process</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Example - ATM</h3>
	<ul>
		<li>Functionality</li>
		<ul>
			<li>An ATM shall dispense money to people presenting a valid debit card and entering the correct PIN</li>
		</ul>
		<li>Usability</li>
		<ul>
			<li>ATM shall be usable for visually impaired people</li>
			<li>ATM shall be usable for colour blind people</li>
		</ul>
		<li>Reliability</li>
		<ul>
			<li>There shall be at most one failure per calender year</li>
			<li>ATM shall be operational at least 99.99% of the time</li>
			<li>After a restart, the ATM shall check the current balance against the main bank system</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Detailed design phase</h3>
	<ul>
		<li>Individual components of the system are specified/designed</li>
		<ul>
			<li>Expected behaviour of functions/methods</li>
			<li>Assumptions about environment</li>
			<li>Invariants of individual components</li>
		</ul>
		<li>Different formalisms possible</li>
		<ul>
			<li>Contracts</li>
			<li>Assume/Assert statements</li>
			<li>...</li>
		</ul>				
	</ul>
</section>

<section>
	<h3>(Function) Contracts</h3>
	<ul>
		<li>Central concept of detailed specification</li>
		<li>Describe <emph>intended behaviour</emph> as a function between</li>
		<ul>
			<li>The <emph>caller</emph> (user of functionality)</li>
			<li>The <emph>callee</emph> (provider of functionality)</li>
		</ul>
		<li>Consists of a pair of</li>
		<ul>
			<li>A set of <emph>preconditions</emph> (assumptions made by callee)</li>
			<li>A set of <emph>postconditions</emph> (guarantees given by callee)</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Example - ATM</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="|1|2|3,4,5|6,7">
		/**
		 * PRE: Card is inserted, user not authenticated
		 * POST: If pin is correct, then user is authenticated
		 * POST: If pin is incorrect, and counter < 0, then 
		 		 counter is incremented by 1, and user is not 
				 authenticated 
		 * POST: If pin is incorrect, and counter >= 2, then card is 
		 		 confiscated and user is not authenticated 
		 */
		bool enterPIN(int pin, int counter); 
	</code></pre>
</section>

<section>
	<h3>Example - Stack</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		#define STACK_SIZE 10 

		int stackData[STACK_SIZE]; 
		int topPointer = 0; 

		void push(int data) {
			stackData[topPointer] = data; 
			topPointer++; 
		}

		int pop() {
			int res = stackData[topPointer]; 
			topPointer--; 
			return res; 
		}
	</code></pre>
</section>

<section>
	<h3>Example - Stack</h3>
	<pre class="C"><code data-trim data-noescape data-line-numbers="">
		#define STACK_SIZE 10 

		int stackData[STACK_SIZE]; 
		int topPointer = 0; 

		/** 
		 * PRE: stack is not full 
		 * POST: data is added as topmost element to the stack 
		 */ 
		void push(int data) {
			stackData[topPointer] = data; 
			topPointer++; 
		}
	</code></pre>
</section>

<section>
	<h3>Specification so far</h3>
	<ul>
		<li>Description still fairly high-level</li>
		<li>Relies on natual language</li>
		<ul>
			<li>Ambiguous</li>
			<li>Cannot be validated automatically</li>
		</ul>
		<li>Need for more specialized specification language</li>
	</ul>
</section>

<section data-background-image="images/mathematics.jpg" data-background-opacity="0.2">
	<h1>Logic</h1>
</section>

<section>
	<h3>Formal specification</h3>
	<ul>
		<li>Need a language to capture</li>
		<ul>
			<li>Preconditions</li>
			<li>Postconditions</li>
			<li>Invariants, assumptions, etc.</li>
		</ul>
		<li>Eventually we would also like to</li>
		<ul>
			<li>use <emph>automation</emph> in testing</li>
			<li>perform <emph>formal verification</emph></li>
		</ul>
	</ul>
</section>

<section>
	<h3>Propositional logic</h3>
	<div>Language: <emph>propositions</emph>, <emph>boolean variables</emph></div>
	<table style="margin-top: 1rem">
		<tr>
			<th>Connective</th>
			<th>Meaning</th>
			<th>C Syntax</th>
		</tr>
		<tr class="fragment fade-up">
			<td>$\neg P$</td>
			<td>not P</td>
			<td>! P</td>
		</tr>
		<tr class="fragment fade-up">
			<td>$P \land Q$</td>
			<td>P and Q</td>
			<td>P && Q</td>
		</tr>
		<tr class="fragment fade-up">
			<td>$P \lor Q$</td>
			<td>P or Q</td>
			<td>P || Q</td>
		</tr>
		<tr class="fragment fade-up">
			<td>$P \rightarrow Q$</td>
			<td>P implies Q</td>
			<td>!P || Q</td>
		</tr>
		<tr class="fragment fade-up">
			<td>$P \leftrightarrow Q$</td>
			<td>P equivalent Q</td>
			<td>P == Q</td>
		</tr>
	</table>
</section>

<section>
	<h3>Propoerties of formulas</h3>
	<div>A formula containing variables P, Q, ... can be</div>
	<ul>
		<li>Satisfiable</li>
		<ul>
			<li>holds for some assignment of values to P, Q, ...</li>
		</ul>
		<li>Valid (tautology)</li>
		<ul>
			<li>Always holds, independent of values of P, Q, ...</li>
		</ul>
		<li>Unsatisfiable</li>
		<li>Invalid</li>
	</ul>
</section>

<section>
	<h3>Useful valid formulas</h3>
	<ul>
		<li>$\neg(\Phi \land \Psi) \leftrightarrow \neg \Phi \lor \neg \Psi$</li>
		<li>$\neg(\Phi \lor \Psi) \leftrightarrow \neg \Phi \land \neg \Psi$</li>
		<li>$(true \land \Phi) \leftrightarrow \Phi$</li>
		<li>$(false \lor \Phi) \leftrightarrow \Phi$</li>
		<li>$\Phi \leftrightarrow true$</li>
		<li>$false \leftrightarrow \Phi$</li>
	</ul>
</section>

<section>
	<h3>Checking propositional formulas</h3>
	<ul>
		<li>By hand</li>
		<ul>
			<li>Truth table</li>
			<li>Formula simplifications</li>
		</ul>
		<li>By using dedicated software tools</li>
		<ul>
			<li>SAT solvers</li>
			<li>Usually also provide a <emph>model</emph> for satisfiable formulas</li>
			<li>SAT is <emph>NP complete</emph>, but often solveable in practice</li>
		</ul>
	</ul>
</section>

<section>
	<h3>Propositional logic in verification</h3>
	<ul>
		<li>Propositional logic is relatively weak</li>
		<ul>
			<li>Cannot express many of the "interesting" properties</li>
			<li>Widely applied for specifying hardware</li>
		</ul>
		<li>Sometimes used for abstractions of programs</li>
		<ul>
			<li>Abstracting a boolean program with same control flow</li>
			<li>E.g. SLAM toolkit</li>
		</ul>
	</ul>
</section>

<section>
	<h3>First-order logic</h3>
	<table style="margin-top: 1rem">
		<tr>
			<th>Connective</th>
			<th>Meaning</th>
			<th>C Syntax</th>
		</tr>
		<tr class="fragment fade-up">
			<td>...</td>
			<td>...</td>
			<td>...</td>
		</tr>
		<tr class="fragment fade-up">
			<td>$\forall x : S.\,P$</td>
			<td>$P(x)$ for all $x \in S$</td>
			<td></td>
		</tr>
		<tr class="fragment fade-up">
			<td>$\exists x : S.\,P$</td>
			<td>$P(x)$ for some $x \in S$</td>
			<td></td>
		</tr>
	</table>
</section>

<section>
	<h3>FOL - Examples</h3>
	<ul>
		<li>Formulas over pre-defined datatypes (e.g. int)</li>
		<ul>
			<li>$x \geq 0 \land y \geq 42 \rightarrow x + y \geq 10$</li>
			<li>$\forall x: S.\, p(x) \rightarrow \exists y: S.\, p(y)$</li>
		</ul>
		<li>Formulas over "uninterpreted" symbols</li>
		<ul>
			<li>$\forall x, y: \mathbb{Z}.\, (x \geq y \rightarrow f(x) \geq f(y)) \rightarrow f(2) \geq f(1)$</li>
			<li>$\forall x: S.\, p(x) \rightarrow \exists y: S.\, p(y)$</li>
		</ul>
	</ul>
</section>

<section>
	<h1>Thanks for today!</h1>
</section>

<!-- END SLIDES -->
</div>
</div>
		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script src="reveal.js/plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				controlsTutorial: false,
				transition: 'fade', 
				slideNumber: 'c', 
				pdfSeparateFragments: false, 
				navigationMode: 'linear', 
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
